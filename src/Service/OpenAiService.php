<?php

declare(strict_types=1);

namespace DigitalExchange\AiMailReply\Service;

use DigitalExchange\AiMailReply\Config\AppConfig;
use DigitalExchange\AiMailReply\Domain\Email;
use DigitalExchange\AiMailReply\Domain\AiResponse;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use Monolog\Logger;

class OpenAiService
{
    private AppConfig $config;
    private Logger $logger;
    private Client $client;
    private string $defaultPrompt;

    public function __construct(AppConfig $config, Logger $logger)
    {
        $this->config = $config;
        $this->logger = $logger;
        $this->client = new Client([
            'base_uri' => 'https://api.openai.com/v1/',
            'headers' => [
                'Authorization' => 'Bearer ' . $config->getOpenaiConfig()['api_key'],
                'Content-Type' => 'application/json',
            ],
        ]);
        $this->defaultPrompt = $config->getDefaultPrompt();
    }

    /**
     * Generate AI response for email
     * 
     * @param Email $email Email object
     * @return AiResponse AI response
     * @throws \Exception If API request fails
     */
    public function generateResponse(Email $email): AiResponse
    {
        try {
            // Prepare prompt
            $prompt = $this->preparePrompt($email);
            
            // Prepare messages for API
            $messages = [
                [
                    'role' => 'system',
                    'content' => $this->defaultPrompt
                ],
                [
                    'role' => 'user',
                    'content' => $prompt
                ]
            ];

            // Add instruction for response format
            $messages[] = [
                'role' => 'system',
                'content' => "Asla Emoji ve Markdown kullanmadan yanƒ±t verme! T√ºm cevaplarƒ±nda Markdown formatƒ±nƒ± kullanmalƒ±sƒ±n ve cevabƒ±nda emojiler kullanmalƒ±sƒ±n.
√ñnemli kelime √∂beklerinin altƒ±nƒ± √ßizmeli (__altƒ± √ßizili__), √∂nemli yerleri bold yapmalƒ± (**kalƒ±n**), kƒ±sa alƒ±ntƒ±larƒ± yatƒ±k yapmalƒ± (*italik*) gibi bi√ßimleri uygulamalƒ±sƒ±n.
Markdown formatƒ±nƒ± kullanmalƒ±sƒ±n. Emojiler i√ßin Unicode UTF-8 kullanmalƒ±sƒ±n. Her ba≈ülƒ±kta en az bir emoji kullanmalƒ±sƒ±n. √ñrneƒüin: üëç üéâ ‚úÖ üòä üëã üöÄ ‚ö†Ô∏è ‚ùó ‚ùì ‚ú® üí° gibi. Emojiler e-posta i√ßeriƒüinde g√∂r√ºnecek ve mesajƒ± daha canlƒ± hale getirecektir."
            ];

            // TODO: Burasƒ± √ßok riskli bir alan, deƒüerlendirilecek. Kesinlikle √ßalƒ±≈ümadƒ±ƒüƒ±na emin olalƒ±m
            if ($this->config->allowAiRecipients() && false) {
                $this->logger->warning('allowAiRecipients', [
                    'info' => "allowAiRecipients is enabled. AI recipients are allowed to be used."
                ]);

                // Add instruction for response format
                $messages[] = [
                    'role' => 'system',
                    'content' => "Yanƒ±tƒ±nƒ± olu≈ütururken, √∂zel talimatlar i√ßin JSON formatƒ±nƒ± kullanabilirsin. Eƒüer sana e-posta g√∂nderen ki≈üi e-postayƒ± sadece kime g√∂ndermen ya da bu e-posta g√∂nderimine eklemen ki≈üileri a√ßƒ±k bir ≈üekilde belirttiyse bunlarƒ±, a≈üaƒüƒ±daki gibi bir JSON bloƒüunda planlayabilirsin:

                    ```json
                    {
                    \"recipients\": [\"ornek@example.com\"],
                    \"cc\": [\"kopya@example.com\"],
                    \"only_to_these_recipients\": true
                    }
                    ```

                    Bu JSON bloƒüu, yanƒ±tƒ±nƒ±n sonunda yer almalƒ±dƒ±r ve normal yanƒ±t metninden ayrƒ± olmalƒ±dƒ±r. JSON bloƒüu olmadan da yanƒ±t verebilirsin, bu durumda varsayƒ±lan olarak t√ºm alƒ±cƒ±lara yanƒ±t g√∂nderilecektir.
                    Sana e-posta g√∂nderen bu e-postayƒ± sadece belli ki≈üilere g√∂ndermeni ya da belli ki≈üileri eklemen gerektiƒüini belirtmediyse kesinlikle eposta akƒ±≈üƒ±nda olan e-postalarƒ± toplayƒ±p cevap verme!
                    Hayali e-postalar uydurma. Burada insanlar tarafƒ±ndan hatalƒ± to ve cc'ler yazƒ±labileceƒüi i√ßin sana kesin olarak verilen direktiflerin dƒ±≈üƒ±na √ßƒ±kmamalƒ±sƒ±n."
                ];
            }

            $this->logger->info('Sent messages to AI : ' . print_r($messages, true));

            // Make API request
            $response = $this->client->post('chat/completions', [
                'json' => [
                    'model' => $this->config->getOpenaiConfig()['model'],
                    'messages' => $messages,
                    'temperature' => 0.7,
                    'max_tokens' => 7000,
                    'top_p' => 0.9,
                    'frequency_penalty' => 0.1,
                    'presence_penalty' => 0.3
                ]
            ]);

            // Parse response
            $responseData = json_decode((string) $response->getBody(), true);

            if (!isset($responseData['choices'][0]['message']['content'])) {
                throw new \Exception('Invalid API response format');
            }

            $aiResponseText = $responseData['choices'][0]['message']['content'];

            // Create AiResponse object
            $aiResponse = AiResponse::fromAiResponseText($aiResponseText);

            $this->logger->info('AI response generated successfully. Response content:', [
                'email_subject' => $email->getSubject(),
                'response_length' => strlen($aiResponseText),
                'response_content' => $aiResponseText,
                'processed_content' => $aiResponse->getContent()
            ]);
            
            return $aiResponse;
        } catch (GuzzleException $e) {
            $this->logger->error('OpenAI API request failed: ' . $e->getMessage());
            throw new \Exception('OpenAI API request failed: ' . $e->getMessage());
        }
    }

    /**
     * Prepare prompt for OpenAI API
     * 
     * @param Email $email Email object
     * @return string Prepared prompt
     */
    private function preparePrompt(Email $email): string
    {
        $prompt = '';

        // Add custom prompt if available
        if ($email->getCustomPrompt() && strlen($email->getCustomPrompt()) === 10) {
            $prompt .= "√ñzel Y√∂nerge: " . $email->getCustomPrompt() . "\n\n";
        }
        
        // Add current email
        $prompt .= "Son E-posta:\n";
        $prompt .= "Kimden: " . $email->getFromName() . " <" . $email->getFrom() . ">\n";
        $prompt .= "Konu: " . $email->getSubject() . "\n";
        
        // Temizlenmi≈ü ve d√ºzg√ºn formatlanmƒ±≈ü i√ßerik
        $cleanBody = $this->cleanEmailContent($email->getBody());
        
        $prompt .= "ƒ∞√ßerik:\n" . $cleanBody . "\n\n";
        
        // Add thread emails if available
        if (!empty($email->getThreadEmails())) {
            $prompt .= "√ñnceki E-postalar:\n";
            
            foreach (array_reverse($email->getThreadEmails()) as $index => $threadEmail) {
                $prompt .= "--- E-posta " . ($index + 1) . " ---\n";
                $prompt .= $threadEmail . "\n\n";
            }
        }
        
        $this->logger->info('Prepare prompt', [
            'prompt' => $prompt
        ]);

        return $prompt;
    }

    /**
     * E-posta i√ßeriƒüini temizleyerek daha okunaklƒ± ve optimize hale getirir.
     * √áe≈üitli e-posta platformlarƒ±yla uyumlu √ßalƒ±≈üƒ±r.
     *
     * @param string $content E-posta i√ßeriƒüi
     * @return string Temizlenmi≈ü i√ßerik
     */
    public function cleanEmailContent(string $content): string
    {
        // Farklƒ± karakter kodlamalarƒ± i√ßin koruma
        if (!mb_check_encoding($content, 'UTF-8')) {
            $content = mb_convert_encoding($content, 'UTF-8', mb_detect_encoding($content, ['UTF-8', 'ISO-8859-9', 'ISO-8859-1'], true));
        }

        // 1. MIME b√∂l√ºmlerini belirle ve "text/plain" olanƒ± ayƒ±kla (daha g√ºvenilir regex)
        if (preg_match('/Content-Type:\s*text\/plain(?:;|\s).*?(?:\n\n|\r\n\r\n)(.*?)(?=\n--[0-9a-zA-Z]+(?:--)?|\Z)/is', $content, $matches)) {
            $plainText = $matches[1];
            // Ba≈üarƒ±yla text/plain i√ßeriƒüi √ßƒ±kartƒ±ldƒ±ysa ve yeterince uzunsa kullan
            if (strlen($plainText) > 5) {
                $content = $plainText;
            }
        }
        
        // Eƒüer multipart mesajsa ve text/plain bulunamadƒ±ysa, alternatif yakla≈üƒ±m
        if (strpos($content, 'Content-Type: multipart/') !== false && !isset($plainText)) {
            // T√ºm MIME b√∂l√ºmlerini bul
            preg_match_all('/--.*?\n(.*?)\n\n(.*?)(?=\n--|\Z)/s', $content, $parts, PREG_SET_ORDER);
            
            foreach ($parts as $part) {
                $headers = $part[1];
                $body = $part[2];
                
                // text/plain b√∂l√ºm√ºn√º bul, HTML i√ßeren b√∂l√ºmleri atla
                if (strpos($headers, 'text/plain') !== false && strpos($headers, 'text/html') === false) {
                    $content = $body;
                    break;
                }
            }
        }

        // 2. Base64 kodlu ekleri temizle (daha kapsamlƒ± regex)
        $content = preg_replace('/--.*?\nContent-Type: (?:image|application)\/.*?(?:\n.*?)*?Content-Transfer-Encoding: base64.*?\n\n[A-Za-z0-9\/\+\r\n=]+/is', '[EK KALDIRILDI]', $content);
        
        // 3. Inline base64 imajlarƒ± kaldƒ±r
        $content = preg_replace('/Content-ID:.*?\nX-Attachment-Id:.*?\n\n[A-Za-z0-9\/\+\r\n=]+/is', '[G√ñRSEL KALDIRILDI]', $content);
        
        // 4. MIME boundary'leri temizle
        $content = preg_replace('/--[0-9a-zA-Z]+(?:--)?\r?\n/i', '', $content);
        
        // 5. Gereksiz ba≈ülƒ±klarƒ± temizle - daha geni≈ü kapsam
        $headersToRemove = [
            'Content-ID:', 
            'X-Attachment-Id:', 
            'Content-Disposition:', 
            'Content-Transfer-Encoding:', 
            'Content-Type:',
            'MIME-Version:',
            'boundary=',
            'charset='
        ];
        
        foreach ($headersToRemove as $header) {
            $content = preg_replace('/' . preg_quote($header, '/') . '.*?\n/im', '', $content);
        }
        
        // 6. HTML etiketlerini temizle
        $content = strip_tags($content);
        
        // 7. Quoted-printable kodlamasƒ±nƒ± √ß√∂z
        $content = quoted_printable_decode($content);
        
        // 8. Ba≈ülƒ±k kodlamalarƒ±nƒ± √ß√∂z (=?UTF-8?B? ve =?UTF-8?Q?) - daha kapsamlƒ±
        $content = preg_replace_callback(
            '/=\?([A-Za-z0-9\-]+)\?([BQ])\?(.*?)\?=/is',
            function ($matches) {
                $charset = $matches[1];
                $encoding = $matches[2];
                $text = $matches[3];
                
                if (strtoupper($encoding) === 'B') {
                    $decoded = base64_decode($text);
                } else {
                    $decoded = quoted_printable_decode(str_replace('_', ' ', $text));
                }
                
                // Farklƒ± karakter seti kullanƒ±lmƒ±≈üsa d√∂n√º≈üt√ºr
                if (strtoupper($charset) !== 'UTF-8') {
                    $decoded = mb_convert_encoding($decoded, 'UTF-8', $charset);
                }
                
                return $decoded;
            },
            $content
        );
        
        // 9. Hex kodlanmƒ±≈ü karakterleri √ß√∂z (=C4=9F ‚Üí 'ƒü')
        $content = preg_replace_callback(
            '/=([0-9A-F]{2})/i',
            function ($matches) {
                return chr(hexdec($matches[1]));
            },
            $content
        );
        
        // 11. Tekrar eden e-posta imzalarƒ±nƒ± temizle (daha g√ºvenilir regex)
        $content = preg_replace('/(\n-- \n.*?)(\1+)/s', '$1', $content);
        //$content = preg_replace('/(-- .*?(?:www\..*?|(?:\+\d{1,4}\s?\d+)+)(?:\n|$)\n*){2,}/s', '$1', $content);
        
        // 12. HTML karakter referanslarƒ±nƒ± √ßevir (&amp; gibi)
        $content = html_entity_decode($content, ENT_QUOTES | ENT_HTML5, 'UTF-8');
        
        // 13. Fazla bo≈üluklarƒ± temizle ve satƒ±r sonlarƒ±nƒ± normalize et
        $content = preg_replace('/[ \t]+/', ' ', $content);
        $content = preg_replace('/\n{3,}/', "\n\n", $content);
        $content = str_replace(["\r\n", "\r"], "\n", $content);
        
        // 14. Uzun URL'leri kƒ±salt (isteƒüe baƒülƒ±)
        //$content = preg_replace('/https?:\/\/[^\s]{40,}/i', '[URL]', $content);
        
        // 15. Son kontroller ve d√ºzeltmeler
        $content = trim($content);
        
        // Tamamen bo≈ü gelirse orijinal i√ßeriƒüi d√∂nd√ºr (g√ºvenlik √∂nlemi)
        if (empty($content) || strlen($content) < 10) {
            // Orjinal i√ßeriƒüi basit√ße temizle
            $original = strip_tags($content);
            $original = preg_replace('/\n{3,}/', "\n\n", $original);
            return trim($original);
        }

        return $content;
    }

}